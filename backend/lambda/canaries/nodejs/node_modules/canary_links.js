const synthetics = require('Synthetics');
const syntheticsConfiguration = synthetics.getConfiguration();
const log = require('SyntheticsLogger');
const BrokenLinkCheckerReport = require('BrokenLinkCheckerReport');
const SyntheticsLink = require('SyntheticsLink');
const syntheticsLogHelper = require('SyntheticsLogHelper');

// ----------------------------------------------------------------------------
// BASIC SYNTHETICS CONFIGURATION ---------------------------------------------
syntheticsConfiguration.setConfig({
  includeRequestHeaders: false,
  includeResponseHeaders: false,
  includeRequestBody: false,
  includeResponseBody: false,
  continueOnHttpStepFailure: false,
  restrictedHeaders: [],
  restrictedUrlParameters: [],
});

// ----------------------------------------------------------------------------
// DEFINING OUR REQUEST OPTIONS -----------------------------------------------
const url = process.env.FRONTEND_URL;
const numOfLinksToReLaunchBrowser = 20;

let brokenLinkCheckerReport = new BrokenLinkCheckerReport();

// ----------------------------------------------------------------------------
// HELPER FUNCTIONS -----------------------------------------------------------

const grabLinks = async function (page, sourceUrl, exploredUrls) {
  let grabbedLinks = [];

  const jsHandle = await page.evaluateHandle(() => {
    return document.getElementsByTagName('a');
  });

  const numberOfLinks = await page.evaluate((e) => e.length, jsHandle);

  for (let i = 0; i < numberOfLinks; i++) {
    let element = await page.evaluate(
      (jsHandle, i, exploredUrls) => {
        let element = jsHandle[i];
        let url = String(element.href).trim();
        // Condition for grabbing a link
        if (
          url != null &&
          url.length > 0 &&
          !exploredUrls.includes(url) &&
          (url.startsWith('http') || url.startsWith('https'))
        ) {
          let text = element.text ? element.text.trim() : '';
          let originalBorderProp = element.style.border;
          element.style.border = '3px solid #e67e22';
          element.scrollIntoViewIfNeeded();
          return { text, url, originalBorderProp };
        }
      },
      jsHandle,
      i,
      captureSourcePageScreenshot,
      exploredUrls
    );

    if (element) {
      let url = element.url;
      let originalBorderProp = element.originalBorderProp;
      exploredUrls.push(url);

      let sourcePageScreenshotResult;
      if (captureSourcePageScreenshot) {
        sourcePageScreenshotResult = await takeScreenshot(getFileName(url), 'sourcePage');

        // Reset css to original
        await page.evaluate(
          (jsHandle, i, originalBorderProp) => {
            let element = jsHandle[i];
            element.style.border = originalBorderProp;
          },
          jsHandle,
          i,
          originalBorderProp
        );
      }

      let link = new SyntheticsLink(url).withParentUrl(sourceUrl).withText(element.text);
      link.addScreenshotResult(sourcePageScreenshotResult);
      grabbedLinks.push(link);
    }
  }
  return grabbedLinks;
};

const takeScreenshot = async function (fileName, suffix) {
  try {
    return await synthetics.takeScreenshot(fileName, suffix);
  } catch (e) {
    synthetics.addExecutionError('Unable to capture screenshot.', e);
  }
};

const getFileName = function (url, defaultName = 'loaded') {
  if (!url) return defaultName;

  const uri = new URL(url);
  const pathname = uri.pathname.replace(/\/$/, ''); //remove trailing '/'
  const fileName = !!pathname ? pathname.split('/').pop() : 'index';

  // Remove characters which can't be used in S3
  return fileName.replace(/[^a-zA-Z0-9-_.!*'()]+/g, '');
};

const resetPage = async function (page) {
  try {
    await page.goto('about:blank', {
      waitUntil: ['load', 'networkidle0'],
      timeout: 30000,
    });
  } catch (e) {
    synthetics.addExecutionError('Unable to open a blank page ', e);
  }
};

const brokenLinkCheckerCanary = async function () {
  const exploredUrls = [url];
  let synLinks = [];
  let count = 0;
  let canaryError = null;
  let brokenLinkError = null;

  let page = await synthetics.getPage();

  exploredUrls.forEach((url) => {
    synLinks.push(new SyntheticsLink(url));
  });

  while (synLinks.length > 0) {
    let link = synLinks.shift();
    let nav_url = link.getUrl();
    let sanitized_url = syntheticsLogHelper.getSanitizedUrl(nav_url);
    link.withUrl(sanitized_url);
    let fileName = getFileName(sanitized_url);
    let response = null;

    count++;

    log.info('Current count: ' + count + ' Checking URL: ' + sanitized_url);

    if (count % numOfLinksToReLaunchBrowser == 0) {
      log.info('Closing current browser and launching new');
      await synthetics.close();
      await synthetics.launch();
      page = await synthetics.getPage();
    } else if (count != 1) {
      await resetPage(page);
    }

    try {
      response = await page.goto(nav_url, {
        waitUntil: ['load', 'networkidle0'],
        timeout: 30000,
      });
      if (!response) {
        brokenLinkError = 'Failed to receive network response for url: ' + sanitized_url;
        log.error(brokenLinkError);
        link = link.withFailureReason('Received null or undefined response.');
      }
    } catch (e) {
      brokenLinkError = 'Failed to load url: ' + sanitized_url + '. ' + e;
      log.error(brokenLinkError);
      link = link.withFailureReason(e.toString());
    }

    await new Promise((r) => setTimeout(r, 5000));

    if (response && response.status() && response.status() < 400) {
      link = link.withStatusCode(response.status()).withStatusText(response.statusText());
      let screenshotResult = await takeScreenshot(fileName, 'succeeded');
      link.addScreenshotResult(screenshotResult);
    } else if (response) {
      const statusString = 'Status code: ' + response.status() + ' ' + response.statusText();
      brokenLinkError = 'Failed to load url: ' + sanitized_url + '. ' + statusString;
      log.info(brokenLinkError);

      link = link
        .withStatusCode(response.status())
        .withStatusText(response.statusText())
        .withFailureReason(statusString);

      let screenshotResult = await takeScreenshot(fileName, 'failed');
      link.addScreenshotResult(screenshotResult);
    }

    try {
      brokenLinkCheckerReport.addLink(link);
    } catch (e) {
      synthetics.addExecutionError('Unable to add link to broken link checker report.', e);
    }

    if (response && response.status() && response.status() < 400) {
      try {
        let moreLinks = await grabLinks(page, sanitized_url, exploredUrls);
        if (moreLinks && moreLinks.length > 0) {
          synLinks = synLinks.concat(moreLinks);
        }
      } catch (e) {
        log.error('Unable to grab urls on page: ' + sanitized_url + '. ' + e);
      }
    }
  }

  try {
    synthetics.addReport(brokenLinkCheckerReport);
  } catch (e) {
    synthetics.addExecutionError('Unable to add broken link checker report.', e);
  }

  log.info('Total links checked: ' + brokenLinkCheckerReport.getTotalLinksChecked());

  if (brokenLinkCheckerReport.getTotalBrokenLinks() != 0) {
    brokenLinkError = brokenLinkCheckerReport.getTotalBrokenLinks() + ' broken link(s) detected. ' + brokenLinkError;
    log.error(brokenLinkError);
    canaryError = canaryError ? brokenLinkError + ' ' + canaryError : brokenLinkError;
  }

  if (canaryError) {
    throw new Error(canaryError);
  }
};

exports.handler = async () => {
  return await brokenLinkCheckerCanary();
};
